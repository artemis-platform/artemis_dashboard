defmodule Artemis.KeyValueTest do
  use Artemis.DataCase
  use ExUnit.Case, async: true

  import Ecto.Repo
  import Artemis.Factories

  alias Artemis.KeyValue

  describe "attributes - primary key" do
    test "uses uuids" do
      record = insert(:key_value)

      assert is_bitstring(record.id)
    end
  end

  describe "attributes - size" do
    test "is generated by changeset" do
      value = "Custom Value"
      expected_size = byte_size(value)
      params = params_for(:key_value, value: value)

      record =
        %KeyValue{}
        |> KeyValue.changeset(params)
        |> Repo.insert!()

      assert record.size == expected_size
      assert record.value == value
    end

    test "cannot be overridden" do
      value = "Custom Value"
      expected_size = byte_size(value)
      custom_size = 1
      params = params_for(:key_value, size: custom_size, value: value)

      record =
        %KeyValue{}
        |> KeyValue.changeset(params)
        |> Repo.insert!()

      assert record.size != custom_size
      assert record.size == expected_size
      assert record.value == value
    end
  end

  describe "attributes - constraints" do
    test "key must be unique" do
      existing = insert(:key_value)

      assert_raise Ecto.ConstraintError, fn ->
        insert(:key_value, key: existing.key)
      end
    end

    test "key must be a binary value" do
      assert_raise RuntimeError, fn ->
        insert(:key_value, key: 'invalid charlist value')
      end

      insert(:key_value, key: <<13, 13, 13>>)
      insert(:key_value, key: "bitstrings are converted by ecto")
      insert(:key_value, key: :erlang.term_to_binary(%{hello: "world"}))
    end

    test "value must be a binary value" do
      assert_raise RuntimeError, fn ->
        insert(:key_value, value: 'invalid charlist value')
      end

      insert(:key_value, value: <<13, 13, 13>>)
      insert(:key_value, value: "bitstrings are converted by ecto")
      insert(:key_value, value: :erlang.term_to_binary(%{hello: "world"}))
    end
  end

  describe "helpers - encode" do
    test "encodes data to binary" do
      encoded_1 = KeyValue.encode("Hello World")
      encoded_2 = KeyValue.encode(%{hello: "world"})

      assert is_binary(encoded_1)
      assert is_binary(encoded_2)

      insert(:key_value, value: encoded_1)
      insert(:key_value, value: encoded_2)
    end

    test "does not double encode - nonbinary map values" do
      value = %{hello: "world"}

      encoded =
        value
        |> KeyValue.encode()
        |> KeyValue.encode()
        |> KeyValue.encode()

      assert is_binary(encoded)
      assert KeyValue.decode(encoded) == value
    end

    test "does not double encode - nonbinary charlist values" do
      value = 'charlist value'

      encoded =
        value
        |> KeyValue.encode()
        |> KeyValue.encode()
        |> KeyValue.encode()

      assert is_binary(encoded)
      assert KeyValue.decode(encoded) == value
    end

    test "does not double encode - nonbinary integer values" do
      value = 1

      encoded =
        value
        |> KeyValue.encode()
        |> KeyValue.encode()
        |> KeyValue.encode()

      assert is_binary(encoded)
      assert KeyValue.decode(encoded) == value
    end

    test "does not double encode - nonbinary float values" do
      value = 1.5

      encoded =
        value
        |> KeyValue.encode()
        |> KeyValue.encode()
        |> KeyValue.encode()

      assert is_binary(encoded)
      assert KeyValue.decode(encoded) == value
    end

    test "does not double encode - binary values" do
      value = "binary value"

      encoded =
        value
        |> KeyValue.encode()
        |> KeyValue.encode()
        |> KeyValue.encode()

      assert is_binary(encoded)
      assert KeyValue.decode(encoded) == value
    end
  end

  describe "helpers - decode" do
    test "decodes data from binary" do
      record = insert(:key_value)
      decoded = KeyValue.decode(record.key)

      assert is_bitstring(decoded)
    end

    test "does not double decode - nonbinary map values" do
      value = %{hello: "world"}

      decoded =
        value
        |> KeyValue.encode()
        |> KeyValue.decode()
        |> KeyValue.decode()

      assert is_map(decoded)
      assert decoded == value
    end

    test "does not double decode - nonbinary charlist values" do
      value = 'charlist value'

      decoded =
        value
        |> KeyValue.encode()
        |> KeyValue.decode()
        |> KeyValue.decode()

      assert decoded == value
    end

    test "does not double decode - nonbinary integer values" do
      value = 1

      decoded =
        value
        |> KeyValue.encode()
        |> KeyValue.decode()
        |> KeyValue.decode()

      assert decoded == value
    end

    test "does not double decode - nonbinary float values" do
      value = 1.5

      decoded =
        value
        |> KeyValue.encode()
        |> KeyValue.decode()
        |> KeyValue.decode()

      assert decoded == value
    end

    test "does not double decode - binary values" do
      value = "binary value"

      decoded =
        value
        |> KeyValue.encode()
        |> KeyValue.decode()
        |> KeyValue.decode()

      assert decoded == value
    end
  end
end
